---
phase: 01-sensor-audio-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/sensors/processors/JerkCalculator.ts
  - src/sensors/processors/SpillRiskNormalizer.ts
  - src/sensors/processors/RollingWindow.ts
  - src/sensors/SensorPipeline.ts
  - src/stores/useSensorStore.ts
autonomous: true

must_haves:
  truths:
    - "Jerk is calculated as rate of acceleration change (dG/dt) per axis"
    - "Combined jerk magnitude uses RMS of lateral and longitudinal components"
    - "Spill risk is normalized to 0-1 range based on jerk vs threshold"
    - "Rolling window smooths transient spikes over ~500ms"
  artifacts:
    - path: "src/sensors/processors/JerkCalculator.ts"
      provides: "Jerk computation from acceleration deltas"
      exports: ["JerkCalculator"]
    - path: "src/sensors/processors/SpillRiskNormalizer.ts"
      provides: "Jerk to risk normalization with difficulty thresholds"
      exports: ["SpillRiskNormalizer"]
    - path: "src/sensors/processors/RollingWindow.ts"
      provides: "Temporal smoothing for risk values"
      exports: ["RollingWindow"]
    - path: "src/sensors/SensorPipeline.ts"
      provides: "Complete synchronous processing pipeline"
      exports: ["SensorPipeline"]
  key_links:
    - from: "src/sensors/SensorPipeline.ts"
      to: "src/sensors/processors/JerkCalculator.ts"
      via: "jerkCalc.compute() in process chain"
      pattern: "jerkCalc\\.compute"
    - from: "src/sensors/SensorPipeline.ts"
      to: "src/sensors/processors/SpillRiskNormalizer.ts"
      via: "riskNorm.normalize() in process chain"
      pattern: "riskNorm\\.normalize"
    - from: "src/sensors/processors/JerkCalculator.ts"
      to: "actual timestamp deltas"
      via: "uses event timestamps, not assumed intervals"
      pattern: "timestamp.*previous"
---

<objective>
Implement the smoothness engine that transforms filtered sensor data into spill risk values.

Purpose: Convert raw motion data into meaningful smoothness metrics. This is the core algorithm that determines whether driving is smooth (silence) or rough (audio feedback).

Output: Complete processing pipeline that takes filtered acceleration, calculates jerk, normalizes to 0-1 risk, and smooths over time. Ready for audio triggering in Plan 03.
</objective>

<execution_context>
@/Users/papanash/.claude/get-shit-done/workflows/execute-plan.md
@/Users/papanash/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-sensor-audio-foundation/01-RESEARCH.md
@.planning/phases/01-sensor-audio-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement jerk calculation and risk normalization</name>
  <files>
    src/sensors/processors/JerkCalculator.ts
    src/sensors/processors/SpillRiskNormalizer.ts
    src/sensors/processors/RollingWindow.ts
  </files>
  <action>
Create src/sensors/processors/JerkCalculator.ts:
- Stores previous acceleration and timestamp
- compute(accel: Vector3, timestamp: number) returns:
  ```typescript
  { x: number; y: number; z: number; magnitude: number }
  ```
- Calculate jerk per axis: `(currentAccel - previousAccel) / deltaTime`
- Use ACTUAL timestamp delta (not assumed 20ms) - critical for Android where intervals vary
- Calculate magnitude as RMS of x (lateral) and y (longitudinal): `sqrt(x^2 + y^2)`
- Exclude z-axis from magnitude (vertical motion is road surface, not driving smoothness)
- reset() clears stored values
- Return zero jerk on first call (no previous data)
- See 01-RESEARCH.md "Jerk Calculator with Actual Delta Time" for reference

Create src/sensors/processors/SpillRiskNormalizer.ts:
- Configurable difficulty thresholds (from 01-CONTEXT.md):
  - Easy: slosh at 5.0 m/s^3, spill at 10.0 m/s^3 (forgiving baseline)
  - Experienced: slosh at 3.0 m/s^3, spill at 7.0 m/s^3
  - Master: slosh at 1.5 m/s^3, spill at 4.0 m/s^3
- normalize(jerkMagnitude: number) returns:
  ```typescript
  { risk: number; isSpill: boolean }
  ```
- Below slosh threshold: risk = 0 (silence = smooth driving)
- Above spill threshold: risk = 1.0, isSpill = true
- Between thresholds: linear interpolation for graduated feedback
- setDifficulty() to change thresholds
- Default to 'easy' difficulty

Create src/sensors/processors/RollingWindow.ts:
- Constructor takes windowMs (default 500ms as per SMTH-04)
- Stores samples with timestamps: { value: number, timestamp: number }[]
- add(value: number, timestamp?: number) returns smoothed average
- Removes samples older than windowMs
- Returns 0 if no samples
- reset() clears all samples
- Use simple array (not circular buffer) - 500ms at 50Hz is only 25 samples
  </action>
  <verify>
- `npx tsc --noEmit` passes
- All three files exist in src/sensors/processors/
- JerkCalculator uses actual timestamps (search for deltaTime calculation)
- SpillRiskNormalizer has three difficulty level threshold sets
- RollingWindow defaults to 500ms window
  </verify>
  <done>
Core smoothness algorithms implemented: jerk calculation with actual deltas, risk normalization with difficulty levels, 500ms rolling window smoothing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SensorPipeline and integrate with store</name>
  <files>
    src/sensors/SensorPipeline.ts
    src/stores/useSensorStore.ts
  </files>
  <action>
Create src/sensors/SensorPipeline.ts:
- Combines LowPassFilter, JerkCalculator, SpillRiskNormalizer, RollingWindow
- Constructor creates instances of all processors
- process(accel: Vector3, timestamp: number) method:
  1. Apply low-pass filter (already done in DeviceMotionManager, but include for completeness)
  2. Calculate jerk from filtered acceleration
  3. Normalize jerk to risk
  4. Smooth risk through rolling window
  5. Return: { risk: number, isSpill: boolean, jerk: Vector3 & { magnitude: number } }
- ALL processing is synchronous - no async boundaries for minimum latency
- setDifficulty() delegates to SpillRiskNormalizer
- reset() resets all processors (for settling period, drive start)

Update src/stores/useSensorStore.ts:
- Add to state:
  - risk: number (0-1 smoothed spill risk)
  - isSpill: boolean (true when spill threshold exceeded)
  - jerkMagnitude: number (for debugging/display)
  - isSettling: boolean (true during startup calibration)
  - difficulty: 'easy' | 'experienced' | 'master'
- Add actions:
  - updateRisk(risk: number, isSpill: boolean, jerkMagnitude: number)
  - setSettling(isSettling: boolean)
  - setDifficulty(difficulty: 'easy' | 'experienced' | 'master')

Implement settling period logic:
- From 01-CONTEXT.md: 1-2 second settling period at startup
- When sensor starts, set isSettling = true
- After 1500ms (Claude's discretion: middle of 1-2s range), set isSettling = false
- During settling, pipeline runs but risk is suppressed (forced to 0)
- This prevents false positives when phone is being mounted
  </action>
  <verify>
- `npx tsc --noEmit` passes
- SensorPipeline.process() returns { risk, isSpill, jerk }
- useSensorStore includes risk, isSpill, isSettling, difficulty
- Settling period is 1500ms
  </verify>
  <done>
Complete sensor pipeline integrated: filtered acceleration flows through jerk -> risk -> smoothing -> store. Settling period prevents startup false positives.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. TypeScript compilation: `npx tsc --noEmit` succeeds
2. All processor files exist in src/sensors/processors/
3. SensorPipeline chains processors synchronously
4. Store has risk/isSpill/isSettling state

Pipeline chain verification:
- DeviceMotionManager (from 01-01) -> LowPassFilter -> JerkCalculator -> SpillRiskNormalizer -> RollingWindow -> Store

Note: Actual sensor testing requires physical device. Algorithm correctness verified in Plan 03 integration.
</verification>

<success_criteria>
- Jerk calculation uses actual timestamp deltas (not assumed intervals)
- Three difficulty levels with distinct thresholds (easy/experienced/master)
- Risk normalized to 0-1 range with linear interpolation
- 500ms rolling window smooths transient spikes
- Settling period (1500ms) prevents startup false positives
- All processing is synchronous for minimum latency
</success_criteria>

<output>
After completion, create `.planning/phases/01-sensor-audio-foundation/01-02-SUMMARY.md`
</output>
