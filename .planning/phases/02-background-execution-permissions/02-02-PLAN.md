---
phase: 02-background-execution-permissions
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - index.ts
  - src/background/BackgroundTaskRegistry.ts
  - src/background/LocationManager.ts
  - src/background/PermissionManager.ts
  - src/stores/useDriveStore.ts
autonomous: true

must_haves:
  truths:
    - "Background location task is registered at app startup"
    - "Location updates can be started and stopped"
    - "Permission flow handles foreground then background requests"
    - "Drive store tracks current drive state"
  artifacts:
    - path: "src/background/BackgroundTaskRegistry.ts"
      provides: "TaskManager.defineTask at module scope"
      exports: ["LOCATION_TASK_NAME"]
      contains: "TaskManager.defineTask"
    - path: "src/background/LocationManager.ts"
      provides: "Start/stop location updates, check if running"
      exports: ["LocationManager"]
    - path: "src/background/PermissionManager.ts"
      provides: "Permission request flow"
      exports: ["PermissionManager"]
    - path: "src/stores/useDriveStore.ts"
      provides: "Drive state management"
      exports: ["useDriveStore"]
  key_links:
    - from: "index.ts"
      to: "src/background/BackgroundTaskRegistry.ts"
      via: "import at top of entry point"
      pattern: "import.*BackgroundTaskRegistry"
    - from: "src/background/BackgroundTaskRegistry.ts"
      to: "expo-task-manager"
      via: "TaskManager.defineTask"
      pattern: "defineTask"
    - from: "src/background/LocationManager.ts"
      to: "expo-location"
      via: "startLocationUpdatesAsync"
      pattern: "startLocationUpdatesAsync"
---

<objective>
Create background task infrastructure with location service and permission management.

Purpose: Wire up the expo-location and expo-task-manager libraries to receive GPS updates in the background. This plan creates the plumbing - the state machine that processes these updates comes in Plan 03.

Output: Background task registered at app startup, LocationManager to start/stop GPS tracking, PermissionManager for permission flow, and useDriveStore for drive state.
</objective>

<execution_context>
@/Users/papanash/.claude/get-shit-done/workflows/execute-plan.md
@/Users/papanash/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-background-execution-permissions/02-CONTEXT.md
@.planning/phases/02-background-execution-permissions/02-RESEARCH.md
@.planning/phases/02-background-execution-permissions/02-01-SUMMARY.md
@src/drive/types.ts
@src/drive/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BackgroundTaskRegistry and update entry point</name>
  <files>src/background/BackgroundTaskRegistry.ts, index.ts</files>
  <action>
1. Create `src/background/BackgroundTaskRegistry.ts`:

```typescript
/**
 * Background Task Registry
 *
 * CRITICAL: This file MUST be imported at the top of the app entry point (index.ts).
 * TaskManager.defineTask must run at module scope, before any React code,
 * because when the app starts in background mode, this is the only code that runs.
 *
 * @see https://docs.expo.dev/versions/latest/sdk/task-manager/
 */

import * as TaskManager from 'expo-task-manager';
import * as Location from 'expo-location';
import { LOCATION_TASK_NAME } from '../drive/constants';
import { LocationData } from '../drive/types';

/** Callback type for location updates */
type LocationUpdateCallback = (locations: LocationData[]) => void;

/** Registered callback for location updates */
let locationCallback: LocationUpdateCallback | null = null;

/**
 * Register a callback to receive location updates.
 * Call this from your state manager/hook before starting location updates.
 */
export function setLocationCallback(callback: LocationUpdateCallback | null): void {
  locationCallback = callback;
}

/**
 * Convert expo-location LocationObject to our LocationData type
 */
function toLocationData(location: Location.LocationObject): LocationData {
  return {
    latitude: location.coords.latitude,
    longitude: location.coords.longitude,
    speed: location.coords.speed,
    timestamp: location.timestamp,
    accuracy: location.coords.accuracy,
  };
}

// Define the background task at module scope
// This runs even when the app starts headless (in background)
TaskManager.defineTask(LOCATION_TASK_NAME, ({ data, error }) => {
  if (error) {
    console.error('[BackgroundTask] Location error:', error.message);
    return;
  }

  if (data) {
    const { locations } = data as { locations: Location.LocationObject[] };

    if (locations && locations.length > 0) {
      const locationData = locations.map(toLocationData);

      // Forward to registered callback
      if (locationCallback) {
        locationCallback(locationData);
      } else {
        // Log for debugging when no callback registered
        console.log('[BackgroundTask] Location received but no callback registered:', {
          count: locations.length,
          latest: locationData[locationData.length - 1],
        });
      }
    }
  }
});

// Export task name for reference
export { LOCATION_TASK_NAME };

console.log('[BackgroundTaskRegistry] Location task registered:', LOCATION_TASK_NAME);
```

2. Update `index.ts` to import BackgroundTaskRegistry at the TOP, before any other imports:

```typescript
// CRITICAL: Import background task registry FIRST
// TaskManager.defineTask must run before React initializes
import './src/background/BackgroundTaskRegistry';

import { registerRootComponent } from 'expo';
import App from './App';

registerRootComponent(App);
```

Note: The BackgroundTaskRegistry import MUST be the very first import in the file. This ensures the task is defined before any React code runs.
  </action>
  <verify>
Run `npx expo start` - app should start without errors. Check console for "[BackgroundTaskRegistry] Location task registered" log message.
  </verify>
  <done>
BackgroundTaskRegistry defines task at module scope, index.ts imports it first, console shows task registration message on app start.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create LocationManager and PermissionManager</name>
  <files>src/background/LocationManager.ts, src/background/PermissionManager.ts</files>
  <action>
1. Create `src/background/LocationManager.ts`:

```typescript
/**
 * LocationManager
 *
 * Wrapper around expo-location for starting/stopping background location updates.
 * Handles the foreground service configuration for Android.
 */

import * as Location from 'expo-location';
import {
  LOCATION_TASK_NAME,
  LOCATION_UPDATE_INTERVAL_MS,
  FOREGROUND_SERVICE_CONFIG,
} from '../drive/constants';

export const LocationManager = {
  /**
   * Check if location updates are currently running
   */
  async isRunning(): Promise<boolean> {
    return Location.hasStartedLocationUpdatesAsync(LOCATION_TASK_NAME);
  },

  /**
   * Start background location updates
   *
   * Prerequisites:
   * - Background location permission granted
   * - setLocationCallback() called with handler
   *
   * @throws Error if permission not granted
   */
  async start(): Promise<void> {
    const isRunning = await this.isRunning();
    if (isRunning) {
      console.log('[LocationManager] Already running, skipping start');
      return;
    }

    console.log('[LocationManager] Starting location updates...');

    await Location.startLocationUpdatesAsync(LOCATION_TASK_NAME, {
      accuracy: Location.Accuracy.High,
      timeInterval: LOCATION_UPDATE_INTERVAL_MS,
      distanceInterval: 0, // Update regardless of distance
      foregroundService: {
        ...FOREGROUND_SERVICE_CONFIG,
      },
      // Deferred updates for battery efficiency when driving steadily
      deferredUpdatesInterval: 5000,
      deferredUpdatesDistance: 10,
      // Continue updates even when app is in background
      pausesUpdatesAutomatically: false,
      // Android: Show notification even when system kills app
      showsBackgroundLocationIndicator: true,
    });

    console.log('[LocationManager] Location updates started');
  },

  /**
   * Stop background location updates
   */
  async stop(): Promise<void> {
    const isRunning = await this.isRunning();
    if (!isRunning) {
      console.log('[LocationManager] Not running, skipping stop');
      return;
    }

    console.log('[LocationManager] Stopping location updates...');
    await Location.stopLocationUpdatesAsync(LOCATION_TASK_NAME);
    console.log('[LocationManager] Location updates stopped');
  },

  /**
   * Get current location (one-shot, for initial position)
   */
  async getCurrentLocation(): Promise<Location.LocationObject | null> {
    try {
      return await Location.getCurrentPositionAsync({
        accuracy: Location.Accuracy.High,
      });
    } catch (error) {
      console.error('[LocationManager] Failed to get current location:', error);
      return null;
    }
  },
};
```

2. Create `src/background/PermissionManager.ts`:

```typescript
/**
 * PermissionManager
 *
 * Handles the permission request flow for location services.
 * Must request foreground permission first, then background.
 */

import * as Location from 'expo-location';
import * as IntentLauncher from 'expo-intent-launcher';
import * as Battery from 'expo-battery';
import { Platform } from 'react-native';
import { LocationPermissionStatus } from '../drive/types';

export const PermissionManager = {
  /**
   * Get current permission status
   */
  async getStatus(): Promise<LocationPermissionStatus> {
    const foreground = await Location.getForegroundPermissionsAsync();

    if (foreground.status !== 'granted') {
      if (foreground.status === 'denied') {
        return 'denied';
      }
      return 'undetermined';
    }

    const background = await Location.getBackgroundPermissionsAsync();

    if (background.status === 'granted') {
      return 'background_granted';
    }

    return 'foreground_only';
  },

  /**
   * Request location permissions (foreground first, then background)
   *
   * @returns Final permission status after requests
   */
  async requestPermissions(): Promise<LocationPermissionStatus> {
    // Step 1: Request foreground permission
    const foreground = await Location.requestForegroundPermissionsAsync();

    if (foreground.status !== 'granted') {
      console.log('[PermissionManager] Foreground permission denied');
      return foreground.status === 'denied' ? 'denied' : 'undetermined';
    }

    console.log('[PermissionManager] Foreground permission granted');

    // Step 2: Request background permission
    // On Android 11+, this opens system settings directly
    const background = await Location.requestBackgroundPermissionsAsync();

    if (background.status === 'granted') {
      console.log('[PermissionManager] Background permission granted');
      return 'background_granted';
    }

    console.log('[PermissionManager] Background permission not granted:', background.status);
    return 'foreground_only';
  },

  /**
   * Check if battery optimization is enabled (Android only)
   * Returns false on iOS
   */
  async isBatteryOptimized(): Promise<boolean> {
    if (Platform.OS !== 'android') {
      return false;
    }

    try {
      return await Battery.isBatteryOptimizationEnabledAsync();
    } catch {
      // Not supported on this device
      return false;
    }
  },

  /**
   * Open battery optimization settings (Android only)
   * Users need to disable battery optimization for reliable background operation
   */
  async openBatterySettings(): Promise<void> {
    if (Platform.OS !== 'android') {
      return;
    }

    try {
      await IntentLauncher.startActivityAsync(
        IntentLauncher.ActivityAction.IGNORE_BATTERY_OPTIMIZATION_SETTINGS
      );
    } catch (error) {
      console.error('[PermissionManager] Failed to open battery settings:', error);
    }
  },

  /**
   * Open app settings (for when permission is permanently denied)
   */
  async openAppSettings(): Promise<void> {
    try {
      if (Platform.OS === 'ios') {
        await IntentLauncher.startActivityAsync(
          IntentLauncher.ActivityAction.APPLICATION_DETAILS_SETTINGS
        );
      } else {
        await IntentLauncher.startActivityAsync(
          IntentLauncher.ActivityAction.APPLICATION_DETAILS_SETTINGS,
          { data: `package:${Platform.OS === 'android' ? 'com.papanash.watercupcoach' : ''}` }
        );
      }
    } catch (error) {
      console.error('[PermissionManager] Failed to open app settings:', error);
    }
  },
};
```

Note: The package name in openAppSettings should match android.package in app.json.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`. No import errors in files.
  </verify>
  <done>
LocationManager exports start(), stop(), isRunning(), getCurrentLocation(). PermissionManager exports getStatus(), requestPermissions(), isBatteryOptimized(), openBatterySettings().
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useDriveStore</name>
  <files>src/stores/useDriveStore.ts</files>
  <action>
Create `src/stores/useDriveStore.ts`:

```typescript
/**
 * Drive Store
 *
 * Zustand store for drive detection state.
 * Manages the drive state machine and GPS-related state.
 *
 * Note: This store is updated less frequently than useSensorStore (once per second vs 50Hz).
 */

import { create } from 'zustand';
import { DriveState, LocationData, LocationPermissionStatus } from '../drive/types';

interface DriveStoreState {
  /** Current drive state machine state */
  driveState: DriveState;

  /** Latest GPS location */
  lastLocation: LocationData | null;

  /** Current speed in m/s (from GPS) */
  currentSpeed: number;

  /** Is GPS signal available */
  hasGpsSignal: boolean;

  /** Location permission status */
  permissionStatus: LocationPermissionStatus;

  /** Is location service currently running */
  isLocationRunning: boolean;

  /** Drive start timestamp (null if not driving) */
  driveStartTime: number | null;
}

interface DriveStoreActions {
  /** Update drive state from state machine */
  setDriveState: (state: DriveState) => void;

  /** Update location data */
  updateLocation: (location: LocationData) => void;

  /** Set GPS signal status */
  setGpsSignal: (hasSignal: boolean) => void;

  /** Set permission status */
  setPermissionStatus: (status: LocationPermissionStatus) => void;

  /** Set location running status */
  setLocationRunning: (running: boolean) => void;

  /** Set drive start time */
  setDriveStartTime: (time: number | null) => void;

  /** Reset to initial state */
  reset: () => void;
}

type DriveStore = DriveStoreState & DriveStoreActions;

const initialState: DriveStoreState = {
  driveState: { type: 'idle' },
  lastLocation: null,
  currentSpeed: 0,
  hasGpsSignal: false,
  permissionStatus: 'undetermined',
  isLocationRunning: false,
  driveStartTime: null,
};

/**
 * Drive store for GPS and drive detection state
 *
 * Usage:
 * ```typescript
 * const driveState = useDriveStore(state => state.driveState);
 * const currentSpeed = useDriveStore(state => state.currentSpeed);
 * const isDriving = driveState.type === 'driving' || driveState.type === 'manual_driving';
 * ```
 */
export const useDriveStore = create<DriveStore>((set) => ({
  ...initialState,

  setDriveState: (driveState: DriveState) => {
    set({ driveState });
  },

  updateLocation: (location: LocationData) => {
    set({
      lastLocation: location,
      currentSpeed: location.speed ?? 0,
      hasGpsSignal: true,
    });
  },

  setGpsSignal: (hasGpsSignal: boolean) => {
    set({ hasGpsSignal });
  },

  setPermissionStatus: (permissionStatus: LocationPermissionStatus) => {
    set({ permissionStatus });
  },

  setLocationRunning: (isLocationRunning: boolean) => {
    set({ isLocationRunning });
  },

  setDriveStartTime: (driveStartTime: number | null) => {
    set({ driveStartTime });
  },

  reset: () => {
    set(initialState);
  },
}));

/**
 * Helper to check if currently in an active drive
 */
export function isDriving(state: DriveState): boolean {
  return state.type === 'driving' || state.type === 'manual_driving' || state.type === 'stopping';
}
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`. Import useDriveStore in a test to verify it works.
  </verify>
  <done>
useDriveStore exports store with driveState, lastLocation, currentSpeed, permissionStatus, and all setters. isDriving() helper exported.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. `npx expo start` - App starts, console shows "[BackgroundTaskRegistry] Location task registered"
3. index.ts has BackgroundTaskRegistry import as first line
4. All managers export the specified functions
</verification>

<success_criteria>
- Background task registered at app startup (visible in console)
- LocationManager can check if running (no actual start yet - that's Plan 03)
- PermissionManager can get current status
- useDriveStore created with initial idle state
- All TypeScript types correct
</success_criteria>

<output>
After completion, create `.planning/phases/02-background-execution-permissions/02-02-SUMMARY.md`
</output>
