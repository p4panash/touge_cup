---
phase: 02-background-execution-permissions
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/drive/DriveStateManager.ts
  - src/hooks/useDriveDetection.ts
  - src/audio/SoundBank.ts
  - App.tsx
autonomous: false

must_haves:
  truths:
    - "Drive auto-starts when speed exceeds 15 km/h for 5 seconds"
    - "Drive auto-stops after 120 seconds stationary"
    - "User can manually start a drive from idle state"
    - "User can manually stop a drive at any time"
    - "Audio feedback continues with screen off"
    - "GPS loss does not crash app - continues with sensors only"
  artifacts:
    - path: "src/drive/DriveStateManager.ts"
      provides: "State machine for drive detection"
      exports: ["DriveStateManager", "processLocation"]
      contains: "processLocation"
    - path: "src/hooks/useDriveDetection.ts"
      provides: "Hook connecting location to state machine"
      exports: ["useDriveDetection"]
  key_links:
    - from: "src/hooks/useDriveDetection.ts"
      to: "src/background/BackgroundTaskRegistry.ts"
      via: "setLocationCallback"
      pattern: "setLocationCallback"
    - from: "src/hooks/useDriveDetection.ts"
      to: "src/drive/DriveStateManager.ts"
      via: "processLocation"
      pattern: "processLocation"
    - from: "src/hooks/useDriveDetection.ts"
      to: "src/background/LocationManager.ts"
      via: "LocationManager.start"
      pattern: "LocationManager\\.(start|stop)"
---

<objective>
Implement drive detection state machine and integrate with App for full background execution.

Purpose: This is the core logic plan - the state machine that processes GPS updates and transitions between idle/detecting/driving/stopping states. Also wires up manual start/stop and enables background audio.

Output: Working drive detection that auto-starts at 15 km/h, auto-stops after 120s stationary, supports manual override, and continues providing audio feedback with screen off.
</objective>

<execution_context>
@/Users/papanash/.claude/get-shit-done/workflows/execute-plan.md
@/Users/papanash/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-background-execution-permissions/02-CONTEXT.md
@.planning/phases/02-background-execution-permissions/02-RESEARCH.md
@.planning/phases/02-background-execution-permissions/02-01-SUMMARY.md
@.planning/phases/02-background-execution-permissions/02-02-SUMMARY.md
@src/drive/types.ts
@src/drive/constants.ts
@src/background/BackgroundTaskRegistry.ts
@src/background/LocationManager.ts
@src/stores/useDriveStore.ts
@src/stores/useSensorStore.ts
@src/audio/SoundBank.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DriveStateManager state machine</name>
  <files>src/drive/DriveStateManager.ts</files>
  <action>
Create `src/drive/DriveStateManager.ts`:

```typescript
/**
 * DriveStateManager
 *
 * Pure state machine for drive detection.
 * Processes location updates and returns new state.
 *
 * State transitions:
 * - idle -> detecting: speed >= 15 km/h
 * - detecting -> idle: speed drops below threshold
 * - detecting -> driving: speed sustained for 5s
 * - driving -> stopping: speed < 3.6 km/h
 * - stopping -> driving: speed resumes
 * - stopping -> idle: stationary for 120s
 * - manual_driving: only manual stop works
 *
 * @see 02-CONTEXT.md for locked thresholds
 */

import { DriveState, LocationData } from './types';
import {
  SPEED_THRESHOLD_MS,
  START_DURATION_MS,
  STOP_DURATION_MS,
  STATIONARY_THRESHOLD_MS,
} from './constants';

/**
 * Result of processing a location update
 */
export interface StateTransitionResult {
  /** New state after processing */
  newState: DriveState;
  /** Did we just start a drive? */
  driveStarted: boolean;
  /** Did we just end a drive? */
  driveEnded: boolean;
}

/**
 * Process a location update and return new state
 *
 * This is a pure function - no side effects.
 * The caller is responsible for updating stores and triggering audio.
 *
 * @param currentState Current drive state
 * @param location GPS location data
 * @returns New state and transition flags
 */
export function processLocation(
  currentState: DriveState,
  location: LocationData
): StateTransitionResult {
  // Handle null speed (GPS not locked) - treat as 0
  const speed = location.speed ?? 0;
  const now = location.timestamp;

  let newState: DriveState = currentState;
  let driveStarted = false;
  let driveEnded = false;

  switch (currentState.type) {
    case 'idle':
      // Check if speed exceeds threshold to start detecting
      if (speed >= SPEED_THRESHOLD_MS) {
        newState = { type: 'detecting', speedAboveThresholdSince: now };
      }
      break;

    case 'detecting':
      if (speed < SPEED_THRESHOLD_MS) {
        // Speed dropped - back to idle
        newState = { type: 'idle' };
      } else if (now - currentState.speedAboveThresholdSince >= START_DURATION_MS) {
        // Sustained speed for 5 seconds - start driving
        newState = { type: 'driving', startTime: currentState.speedAboveThresholdSince };
        driveStarted = true;
      }
      // else: still detecting, no state change
      break;

    case 'driving':
      if (speed < STATIONARY_THRESHOLD_MS) {
        // Nearly stationary - start stop countdown
        newState = {
          type: 'stopping',
          stationarySince: now,
          driveStartTime: currentState.startTime,
        };
      }
      // else: still driving, no state change
      break;

    case 'stopping':
      if (speed >= STATIONARY_THRESHOLD_MS) {
        // Moving again - resume driving
        newState = { type: 'driving', startTime: currentState.driveStartTime };
      } else if (now - currentState.stationarySince >= STOP_DURATION_MS) {
        // Stationary for 120 seconds - end drive
        newState = { type: 'idle' };
        driveEnded = true;
      }
      // else: still stopping, no state change
      break;

    case 'manual_driving':
      // Manual mode ignores auto-stop logic
      // Only manual stop can end this state
      break;
  }

  return { newState, driveStarted, driveEnded };
}

/**
 * DriveStateManager singleton for managing state transitions
 */
export const DriveStateManager = {
  /**
   * Start a manual drive (user pressed start)
   * Only works from idle state
   */
  startManualDrive(currentState: DriveState): DriveState {
    if (currentState.type === 'idle') {
      return { type: 'manual_driving', startTime: Date.now() };
    }
    // If already driving, convert to manual
    if (currentState.type === 'driving') {
      return { type: 'manual_driving', startTime: currentState.startTime };
    }
    if (currentState.type === 'detecting') {
      return { type: 'manual_driving', startTime: Date.now() };
    }
    if (currentState.type === 'stopping') {
      return { type: 'manual_driving', startTime: currentState.driveStartTime };
    }
    // Already manual, no change
    return currentState;
  },

  /**
   * Stop a drive manually (user pressed stop)
   * Works from any driving state
   */
  stopManualDrive(currentState: DriveState): DriveState {
    if (
      currentState.type === 'driving' ||
      currentState.type === 'manual_driving' ||
      currentState.type === 'stopping'
    ) {
      return { type: 'idle' };
    }
    // Not driving, no change
    return currentState;
  },
};
```

Note: processLocation is a pure function for testability. Side effects (store updates, audio) happen in the hook.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`.
  </verify>
  <done>
DriveStateManager.ts exports processLocation() pure function and DriveStateManager singleton with startManualDrive() and stopManualDrive().
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useDriveDetection hook and enable background audio</name>
  <files>src/hooks/useDriveDetection.ts, src/audio/SoundBank.ts</files>
  <action>
1. Create `src/hooks/useDriveDetection.ts`:

```typescript
/**
 * useDriveDetection Hook
 *
 * Connects GPS location updates to the drive state machine.
 * Manages location service lifecycle and permission requests.
 */

import { useEffect, useCallback, useRef } from 'react';
import { Audio } from 'expo-av';
import { useDriveStore, isDriving } from '../stores/useDriveStore';
import { useSensorStore } from '../stores/useSensorStore';
import { setLocationCallback } from '../background/BackgroundTaskRegistry';
import { LocationManager } from '../background/LocationManager';
import { PermissionManager } from '../background/PermissionManager';
import { processLocation, DriveStateManager } from '../drive/DriveStateManager';
import { LocationData } from '../drive/types';

/**
 * Hook for drive detection
 *
 * Responsibilities:
 * 1. Request permissions and start location updates
 * 2. Process location updates through state machine
 * 3. Update drive store with new state
 * 4. Handle manual start/stop
 *
 * Usage:
 * ```typescript
 * const { startManual, stopManual, requestPermissions } = useDriveDetection();
 * ```
 */
export function useDriveDetection() {
  const driveState = useDriveStore((s) => s.driveState);
  const setDriveState = useDriveStore((s) => s.setDriveState);
  const updateLocation = useDriveStore((s) => s.updateLocation);
  const setGpsSignal = useDriveStore((s) => s.setGpsSignal);
  const setPermissionStatus = useDriveStore((s) => s.setPermissionStatus);
  const setLocationRunning = useDriveStore((s) => s.setLocationRunning);
  const setDriveStartTime = useDriveStore((s) => s.setDriveStartTime);

  // Track if we've configured audio for background
  const audioConfiguredRef = useRef(false);

  // Configure audio for background playback
  useEffect(() => {
    async function configureBackgroundAudio() {
      if (audioConfiguredRef.current) return;

      try {
        await Audio.setAudioModeAsync({
          playsInSilentModeIOS: true,
          staysActiveInBackground: true, // KEY: Enable background audio
          shouldDuckAndroid: true,
          playThroughEarpieceAndroid: false,
        });
        audioConfiguredRef.current = true;
        console.log('[useDriveDetection] Background audio configured');
      } catch (error) {
        console.error('[useDriveDetection] Failed to configure audio:', error);
      }
    }

    configureBackgroundAudio();
  }, []);

  // Handle location updates from background task
  const handleLocationUpdate = useCallback(
    (locations: LocationData[]) => {
      // Process the latest location
      const location = locations[locations.length - 1];
      if (!location) return;

      // Update store with location data
      updateLocation(location);

      // Get current state and process through state machine
      const currentState = useDriveStore.getState().driveState;
      const { newState, driveStarted, driveEnded } = processLocation(currentState, location);

      // Update state if changed
      if (newState !== currentState) {
        setDriveState(newState);

        if (driveStarted) {
          const startTime = 'startTime' in newState ? newState.startTime : Date.now();
          setDriveStartTime(startTime);
          console.log('[useDriveDetection] Drive auto-started at speed:', location.speed);
        }

        if (driveEnded) {
          setDriveStartTime(null);
          console.log('[useDriveDetection] Drive auto-stopped after 120s stationary');
        }
      }
    },
    [updateLocation, setDriveState, setDriveStartTime]
  );

  // Register location callback on mount
  useEffect(() => {
    setLocationCallback(handleLocationUpdate);

    return () => {
      setLocationCallback(null);
    };
  }, [handleLocationUpdate]);

  // Request permissions and start location
  const requestPermissions = useCallback(async () => {
    const status = await PermissionManager.requestPermissions();
    setPermissionStatus(status);

    if (status === 'background_granted') {
      // Start location updates
      await LocationManager.start();
      setLocationRunning(true);
    }

    return status;
  }, [setPermissionStatus, setLocationRunning]);

  // Check initial permission status
  useEffect(() => {
    async function checkPermissions() {
      const status = await PermissionManager.getStatus();
      setPermissionStatus(status);

      // If already have background permission, start location
      if (status === 'background_granted') {
        const isRunning = await LocationManager.isRunning();
        if (!isRunning) {
          await LocationManager.start();
        }
        setLocationRunning(true);
      }
    }

    checkPermissions();
  }, [setPermissionStatus, setLocationRunning]);

  // Manual start
  const startManual = useCallback(() => {
    const currentState = useDriveStore.getState().driveState;
    const newState = DriveStateManager.startManualDrive(currentState);
    setDriveState(newState);

    if ('startTime' in newState) {
      setDriveStartTime(newState.startTime);
    }
    console.log('[useDriveDetection] Manual drive started');
  }, [setDriveState, setDriveStartTime]);

  // Manual stop
  const stopManual = useCallback(() => {
    const currentState = useDriveStore.getState().driveState;
    const wasDriving = isDriving(currentState);
    const newState = DriveStateManager.stopManualDrive(currentState);
    setDriveState(newState);

    if (wasDriving) {
      setDriveStartTime(null);
      console.log('[useDriveDetection] Manual drive stopped');
    }
  }, [setDriveState, setDriveStartTime]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      // Don't stop location on unmount - we want it to continue in background
      // Only stop explicitly via stopManual
    };
  }, []);

  return {
    driveState,
    requestPermissions,
    startManual,
    stopManual,
    isDriving: isDriving(driveState),
  };
}
```

2. Update `src/audio/SoundBank.ts` to enable background audio mode on initialization. Find the initialize function and ensure `setAudioModeAsync` includes `staysActiveInBackground: true`. If SoundBank already has audio mode configuration, update it; if not, add it to the preload sequence.

The key change is ensuring:
```typescript
await Audio.setAudioModeAsync({
  playsInSilentModeIOS: true,
  staysActiveInBackground: true, // Add this if missing
  shouldDuckAndroid: true,
  playThroughEarpieceAndroid: false,
});
```

Note: The hook also configures audio, but having it in SoundBank ensures it's set during initial load.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`. Run app and check console for background audio configuration message.
  </verify>
  <done>
useDriveDetection exports requestPermissions(), startManual(), stopManual(), isDriving. Background audio mode enabled with staysActiveInBackground: true.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate drive detection into App</name>
  <files>App.tsx</files>
  <action>
Update `App.tsx` to:

1. Import and use useDriveDetection hook
2. Add drive state to the debug UI
3. Add manual start/stop buttons
4. Add permission request button if not granted
5. Show current speed and drive state

The App should:
- Show permission status and request button if needed
- Show current GPS speed
- Show drive state (idle/detecting/driving/stopping/manual)
- Show Start Drive / Stop Drive buttons
- Continue showing existing sensor debug info (risk, settling, etc.)

Integration pattern:
```typescript
import { useDriveDetection } from './src/hooks/useDriveDetection';
import { useDriveStore } from './src/stores/useDriveStore';

// In component:
const { requestPermissions, startManual, stopManual, isDriving } = useDriveDetection();
const permissionStatus = useDriveStore(s => s.permissionStatus);
const currentSpeed = useDriveStore(s => s.currentSpeed);
const driveState = useDriveStore(s => s.driveState);

// Convert speed to km/h for display
const speedKmh = (currentSpeed * 3.6).toFixed(1);
```

Add a section in the UI for drive status:
- "GPS Speed: XX.X km/h"
- "Drive State: [state.type]"
- "Permission: [status]"
- Button: "Request Location Permission" (if not background_granted)
- Button: "Start Drive" (if idle) / "Stop Drive" (if driving)

Keep the existing sensor pipeline and audio feedback UI intact.
  </action>
  <verify>
App compiles and runs. Permission button visible. After granting permission, speed shows values. Drive state transitions visible.
  </verify>
  <done>
App.tsx integrates useDriveDetection, shows GPS speed, drive state, permission status, and manual start/stop buttons.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete drive detection system with:
- GPS speed monitoring via expo-location
- Auto-start at 15 km/h sustained for 5 seconds
- Auto-stop after 120 seconds stationary
- Manual start/stop override
- Background audio feedback (screen off)
- Permission request flow
  </what-built>
  <how-to-verify>
1. Install updated app on physical device: `npx expo run:ios` or `npx expo run:android`
2. Grant location permission when prompted (select "Always" for background)
3. **Test auto-start**: Start moving at driving speed (>15 km/h) - watch state change from idle -> detecting -> driving
4. **Test manual stop**: Press "Stop Drive" button - state should go to idle
5. **Test manual start**: Press "Start Drive" while stationary - state should go to manual_driving
6. **Test background**: Lock screen, continue driving - audio feedback should still work
7. **Test auto-stop**: Stop the car, wait 2 minutes - state should go from driving -> stopping -> idle
8. Check battery usage in system settings after 10+ minutes of use

Expected behaviors:
- State transitions visible in UI
- Audio feedback continues with screen locked
- No crashes when GPS signal lost briefly
- Permission request flow works on both platforms
  </how-to-verify>
  <resume-signal>Type "approved" if drive detection works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. App starts without errors
2. Permission flow works (foreground then background)
3. GPS speed displays and updates
4. Drive state machine transitions correctly
5. Manual start/stop works
6. Audio continues with screen off
7. No crashes on GPS loss
</verification>

<success_criteria>
Phase 2 success criteria:
1. App auto-starts recording when user drives above 15 km/h for 5+ seconds
2. App auto-stops recording when user is stationary for 120+ seconds
3. User can manually start and stop drives at any time
4. Drive detection and audio feedback continue with screen off for 30+ minutes
5. Battery consumption reasonable (target <10% for 1-hour drive - verify in checkpoint)
</success_criteria>

<output>
After completion, create `.planning/phases/02-background-execution-permissions/02-03-SUMMARY.md`
</output>
