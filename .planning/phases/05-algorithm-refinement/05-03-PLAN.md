---
phase: 05-algorithm-refinement
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/hooks/useAudioFeedback.ts
  - src/audio/FeedbackTrigger.ts
  - src/stores/useSensorStore.ts
autonomous: true

must_haves:
  truths:
    - "Potholes on Easy/Experienced modes play distinct sound and are marked as forgiven"
    - "Potholes on Master mode count as spills"
    - "Master mode plays ambient that intensifies with risk"
    - "Master mode spill triggers dramatic splash + ambient silence + streak broken"
    - "Easy/Experienced modes audio is unchanged from current behavior"
  artifacts:
    - path: "src/hooks/useAudioFeedback.ts"
      provides: "Difficulty-aware audio feedback with pothole and ambient support"
      contains: "AmbientAudioController"
    - path: "src/audio/FeedbackTrigger.ts"
      provides: "Extended trigger logic for difficulty-specific sounds"
      contains: "spill-dramatic"
    - path: "src/stores/useSensorStore.ts"
      provides: "Pothole event state for UI"
      contains: "lastPothole"
  key_links:
    - from: "src/hooks/useAudioFeedback.ts"
      to: "src/audio/AmbientAudioController.ts"
      via: "instantiation and lifecycle management"
      pattern: "ambientController"
    - from: "src/hooks/useAudioFeedback.ts"
      to: "src/services/DriveRecorder.ts"
      via: "logPothole call"
      pattern: "DriveRecorder\\.logPothole"
---

<objective>
Wire pothole detection and Master mode ambient into the audio feedback system with difficulty-aware behavior.

Purpose: Complete Phase 5 by connecting the pothole detection (Plan 01) and ambient audio (Plan 02) systems to the existing feedback loop. Each difficulty level should feel distinct - Easy/Experienced are forgiving, Master is immersive and strict.

Output: Fully integrated difficulty-aware audio system where potholes are handled appropriately per difficulty and Master mode has reactive ambient soundscape.
</objective>

<execution_context>
@/Users/papanash/.claude/get-shit-done/workflows/execute-plan.md
@/Users/papanash/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-algorithm-refinement/05-CONTEXT.md
@.planning/phases/05-algorithm-refinement/05-RESEARCH.md
@.planning/phases/05-algorithm-refinement/05-01-SUMMARY.md
@.planning/phases/05-algorithm-refinement/05-02-SUMMARY.md

@src/hooks/useAudioFeedback.ts
@src/audio/FeedbackTrigger.ts
@src/stores/useSensorStore.ts
@src/services/DriveRecorder.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update useSensorStore with pothole state</name>
  <files>src/stores/useSensorStore.ts</files>
  <action>
Add pothole tracking state to the sensor store:

1. Import PotholeEvent type from '../sensors/types' (or from PotholeDetector)

2. Add to SensorState interface:
   - lastPothole: PotholeEvent | null (most recent pothole for UI display)

3. Add to SensorActions interface:
   - setPothole: (pothole: PotholeEvent | null) => void

4. Add to initialState:
   - lastPothole: null

5. Implement setPothole action in the store:
   ```typescript
   setPothole: (pothole: PotholeEvent | null) => {
     set({ lastPothole: pothole });
   },
   ```

6. Update resetSensorState to also clear lastPothole

Note: Do NOT persist lastPothole - it's transient session state like risk and jerk.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
useSensorStore has lastPothole state and setPothole action for UI reactivity.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update FeedbackTrigger for difficulty-specific sounds</name>
  <files>src/audio/FeedbackTrigger.ts</files>
  <action>
Extend FeedbackTrigger to support difficulty-specific audio behavior:

1. Import DifficultyLevel type from stores/useSensorStore (or sensors/processors/SpillRiskNormalizer)

2. Add private difficulty field with setter:
   ```typescript
   private difficulty: DifficultyLevel = 'easy';

   setDifficulty(difficulty: DifficultyLevel): void {
     this.difficulty = difficulty;
   }
   ```

3. Add method to evaluate pothole events:
   ```typescript
   evaluatePothole(pothole: PotholeEvent): {
     sound: SoundName | null;
     countAsSpill: boolean;
     forgiven: boolean;
   } {
     if (this.difficulty === 'master') {
       // Master mode: potholes count as spills, no special sound
       return { sound: null, countAsSpill: true, forgiven: false };
     }
     // Easy/Experienced: play bump sound, forgive the event
     return { sound: 'pothole-bump', countAsSpill: false, forgiven: true };
   }
   ```

4. Update the existing evaluate() method to return difficulty-specific spill sound:
   - When isSpill is true and this.difficulty === 'master':
     - Return 'spill-dramatic' instead of 'spill'
   - Otherwise return 'spill' as before

5. Add a getter for current difficulty:
   ```typescript
   getDifficulty(): DifficultyLevel {
     return this.difficulty;
   }
   ```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
FeedbackTrigger returns 'spill-dramatic' for Master mode spills and handles pothole evaluation with forgiveness logic.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire pothole detection and ambient into useAudioFeedback</name>
  <files>src/hooks/useAudioFeedback.ts</files>
  <action>
Integrate pothole handling and Master mode ambient into the audio feedback hook:

1. Add imports:
   - AmbientAudioController from '../audio/AmbientAudioController'
   - PotholeEvent from '../sensors/types'

2. Add refs for ambient controller:
   ```typescript
   const ambientControllerRef = useRef<AmbientAudioController | null>(null);
   ```

3. Subscribe to pothole events from sensor pipeline:
   - Add selector for pipeline result pothole field (if exposed via store)
   - OR subscribe to useSensorStore lastPothole if you prefer to push from useSensorPipeline

   For cleaner architecture, the useSensorPipeline hook should push pothole events to useSensorStore.
   Add effect that responds to lastPothole changes.

4. Add effect to initialize/cleanup ambient based on difficulty:
   ```typescript
   useEffect(() => {
     const difficulty = useSensorStore.getState().difficulty;
     triggerRef.current.setDifficulty(difficulty);

     if (difficulty === 'master' && isCurrentlyDriving) {
       // Initialize and start ambient for Master mode
       if (!ambientControllerRef.current) {
         ambientControllerRef.current = new AmbientAudioController();
         ambientControllerRef.current.initialize().then(() => {
           ambientControllerRef.current?.start();
         });
       }
     } else {
       // Cleanup ambient for non-Master modes
       if (ambientControllerRef.current) {
         ambientControllerRef.current.cleanup();
         ambientControllerRef.current = null;
       }
     }

     return () => {
       // Cleanup on unmount
       ambientControllerRef.current?.cleanup();
     };
   }, [difficulty, isCurrentlyDriving]);
   ```

5. Update the main risk effect to handle pothole and ambient:
   In the existing useEffect that triggers audio based on risk:

   a. Update ambient volume when in Master mode:
      ```typescript
      if (ambientControllerRef.current) {
        ambientControllerRef.current.setRiskLevel(risk);
      }
      ```

   b. Handle spill in Master mode:
      ```typescript
      if (sound === 'spill-dramatic' && ambientControllerRef.current) {
        ambientControllerRef.current.onSpill();
      }
      ```

6. Add effect to handle pothole events:
   ```typescript
   const lastPothole = useSensorStore((state) => state.lastPothole);

   useEffect(() => {
     if (!lastPothole || !isCurrentlyDriving || isSettling || isAudioInterrupted) {
       return;
     }

     const result = triggerRef.current.evaluatePothole(lastPothole);

     // Play pothole sound if any
     if (result.sound) {
       audioEngine.play(result.sound);
     }

     // Log to database
     const lastLocation = useDriveStore.getState().lastLocation;
     DriveRecorder.logPothole({
       timestamp: lastPothole.timestamp,
       location: lastLocation,
       severity: lastPothole.zPeak / 10, // Normalize to 0-1 range
       forgiven: result.forgiven,
     }).catch(err => console.error('[AudioFeedback] Failed to log pothole:', err));

     // If Master mode and pothole counts as spill, trigger spill sound too
     if (result.countAsSpill) {
       const spillSound = triggerRef.current.evaluate(1.0, true);
       if (spillSound) {
         audioEngine.play(spillSound);
         // Also trigger ambient silence
         ambientControllerRef.current?.onSpill();
       }
     }

     // Clear the pothole event after processing
     useSensorStore.getState().setPothole(null);
   }, [lastPothole, isCurrentlyDriving, isSettling, isAudioInterrupted]);
   ```

7. Update useSensorPipeline hook to push pothole events:
   In the file src/hooks/useSensorPipeline.ts, after processing sensor data through pipeline:
   ```typescript
   if (result.pothole) {
     useSensorStore.getState().setPothole(result.pothole);
   }
   ```

8. Subscribe to difficulty changes:
   ```typescript
   const difficulty = useSensorStore((state) => state.difficulty);
   ```
   Add difficulty to the dependencies of relevant effects.

9. Cleanup ambient when drive ends (in the isActive effect):
   ```typescript
   useEffect(() => {
     if (!isActive) {
       triggerRef.current.reset();
       setCurrentZone('silent');
       setLastPlayedSound(null);
       // Also cleanup ambient
       ambientControllerRef.current?.stop();
     }
   }, [isActive]);
   ```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Run app on device: Start a drive on Easy mode - potholes should play bump sound.
Run app on device: Start a drive on Master mode - ambient should play, intensify with risk, go silent on spill.
  </verify>
  <done>
useAudioFeedback handles:
- Pothole detection with forgiveness on Easy/Experienced
- Pothole counting as spill on Master
- Master mode ambient that intensifies with risk
- Ambient silence on spill with gradual rebuild
- Difficulty-specific spill sounds (dramatic on Master)
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. App starts without crashes: `npx expo start`
3. On Easy/Experienced: Pothole plays bump sound, does not count as spill
4. On Master: Pothole counts as spill, dramatic splash plays
5. On Master: Ambient sound plays during drive, volume scales with risk
6. On Master: Spill triggers ambient silence, then gradual rebuild
7. Difficulty change during drive updates audio behavior correctly
</verification>

<success_criteria>
- Easy mode: Potholes play distinct bump sound, are forgiven, regular spill sound plays
- Experienced mode: Same as Easy (potholes forgiven)
- Master mode: Potholes count as spills, dramatic splash, ambient present, silence on spill
- Ambient volume scales 0.15-0.7 based on risk proximity to threshold
- Audio behavior switches correctly when difficulty changes
- All events logged correctly to database with forgiven flag
</success_criteria>

<output>
After completion, create `.planning/phases/05-algorithm-refinement/05-03-SUMMARY.md`
</output>
