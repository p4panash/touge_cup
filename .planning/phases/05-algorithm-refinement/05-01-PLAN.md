---
phase: 05-algorithm-refinement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/sensors/processors/PotholeDetector.ts
  - src/sensors/SensorPipeline.ts
  - src/sensors/types.ts
autonomous: true

must_haves:
  truths:
    - "Z-axis spikes greater than 3.9 m/s^2 and shorter than 200ms are detected as potholes"
    - "Speed bumps (>200ms duration) are NOT classified as potholes"
    - "Consecutive potholes within 7 seconds cluster as one rough road event"
    - "Filtered Z-axis acceleration is exposed from sensor pipeline"
  artifacts:
    - path: "src/sensors/processors/PotholeDetector.ts"
      provides: "Z-axis spike detection with duration filtering"
      exports: ["PotholeDetector", "PotholeEvent"]
    - path: "src/sensors/SensorPipeline.ts"
      provides: "Extended pipeline result with pothole detection"
      contains: "zAccelFiltered"
  key_links:
    - from: "src/sensors/SensorPipeline.ts"
      to: "src/sensors/processors/PotholeDetector.ts"
      via: "instantiation and detect() call"
      pattern: "potholeDetector\\.detect"
---

<objective>
Create the pothole detection system that identifies road imperfections via Z-axis acceleration spikes.

Purpose: Distinguish potholes from driver errors so they can be forgiven on Easy/Experienced modes. The water cup metaphor should punish rough driving, not rough roads.

Output: PotholeDetector class that integrates into SensorPipeline and produces pothole events for downstream processing.
</objective>

<execution_context>
@/Users/papanash/.claude/get-shit-done/workflows/execute-plan.md
@/Users/papanash/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-algorithm-refinement/05-CONTEXT.md
@.planning/phases/05-algorithm-refinement/05-RESEARCH.md

@src/sensors/processors/JerkCalculator.ts
@src/sensors/SensorPipeline.ts
@src/sensors/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PotholeDetector class</name>
  <files>src/sensors/processors/PotholeDetector.ts</files>
  <action>
Create PotholeDetector class that detects road imperfections via Z-axis acceleration spikes:

1. Define PotholeEvent interface:
   - timestamp: number (ms)
   - zPeak: number (peak Z-axis deviation in m/s^2)
   - duration: number (spike duration in ms)
   - forgiven: boolean (set by caller based on difficulty)

2. Implement PotholeDetector class with constants:
   - Z_THRESHOLD = 3.9 m/s^2 (0.4g per research)
   - MAX_POTHOLE_DURATION_MS = 200 (distinguishes from speed bumps)
   - CLUSTER_WINDOW_MS = 7000 (middle of 5-10s range per CONTEXT.md)
   - HYSTERESIS_FACTOR = 0.5 (spike must drop to 50% of threshold to end)

3. Track internal state:
   - spikeStartTime: number | null
   - spikeStartZ: number (peak during current spike)
   - lastPotholeTime: number (for clustering)
   - inRoughRoad: boolean (suppresses clustered potholes)

4. Implement detect(zAccel: number, timestamp: number) method:
   - zAccel is already gravity-compensated from DeviceMotion
   - Start spike tracking when |zAccel| > Z_THRESHOLD
   - Track peak Z during spike
   - End spike when |zAccel| < Z_THRESHOLD * HYSTERESIS_FACTOR
   - Return PotholeEvent only if duration < MAX_POTHOLE_DURATION_MS
   - Apply clustering: if within CLUSTER_WINDOW_MS of last pothole and already in rough road, return null
   - Update inRoughRoad flag based on clustering

5. Implement reset() method to clear all state

Reference JerkCalculator.ts for similar pattern with timestamp tracking.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
PotholeDetector.ts exists with detect() method that returns PotholeEvent for Z-axis spikes under 200ms and null for speed bumps or clustered events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update sensor types with pothole-related fields</name>
  <files>src/sensors/types.ts</files>
  <action>
Update the sensor types file to include pothole detection types:

1. Export the PotholeEvent interface (re-export from PotholeDetector or define here for consistency with other types):
   - timestamp: number
   - zPeak: number
   - duration: number
   - forgiven: boolean

2. No changes to Vector3 or FilteredSensorData needed - Z-axis already included.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
Pothole-related types are accessible from src/sensors/types.ts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate PotholeDetector into SensorPipeline</name>
  <files>src/sensors/SensorPipeline.ts</files>
  <action>
Update SensorPipeline to include pothole detection:

1. Import PotholeDetector and PotholeEvent from './processors/PotholeDetector'

2. Add to PipelineResult interface:
   - zAccelFiltered: number (filtered Z-axis acceleration for downstream use)
   - pothole: PotholeEvent | null (detected pothole event, or null)

3. Add potholeDetector as class member, instantiated in constructor

4. In process() method, after low-pass filtering:
   - Store filtered.z for return value
   - Call potholeDetector.detect(filtered.z, timestamp * 1000)
   - Note: timestamp comes in as seconds, convert to ms for pothole detector
   - Include pothole result in return object

5. Update reset() to also call potholeDetector.reset()

The pipeline still returns immediately - pothole detection adds minimal overhead (simple threshold checks, no I/O).
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Manual test: Run app, check console logs don't show errors related to pipeline.
  </verify>
  <done>
SensorPipeline.process() returns PipelineResult with zAccelFiltered and pothole fields. Pothole detection runs on every sensor sample without blocking.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. PotholeDetector exists at src/sensors/processors/PotholeDetector.ts
3. PipelineResult includes zAccelFiltered and pothole fields
4. App starts without crashes: `npx expo start`
</verification>

<success_criteria>
- Z-axis spikes are detected and classified as pothole events when duration < 200ms
- Speed bumps (longer duration) do not produce pothole events
- Consecutive potholes within 7 seconds are clustered
- Filtered Z-axis acceleration is exposed for debugging/display
- No impact on existing jerk-based spill detection
</success_criteria>

<output>
After completion, create `.planning/phases/05-algorithm-refinement/05-01-SUMMARY.md`
</output>
