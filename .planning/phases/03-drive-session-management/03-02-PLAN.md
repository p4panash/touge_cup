---
phase: 03-drive-session-management
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/services/DriveRecorder.ts
  - src/db/queries/drives.ts
  - src/db/queries/events.ts
  - src/db/queries/breadcrumbs.ts
  - src/hooks/useDriveDetection.ts
  - src/hooks/useAudioFeedback.ts
  - src/stores/useDriveStore.ts
autonomous: true

must_haves:
  truths:
    - "Drive start creates a new drive record in database"
    - "GPS breadcrumbs are recorded every 5 seconds during active drive"
    - "Spill events are logged with timestamp, location, and severity"
    - "Drive end updates the drive record with duration and counts"
  artifacts:
    - path: "src/services/DriveRecorder.ts"
      provides: "Orchestrates drive session lifecycle and event capture"
      exports: ["DriveRecorder"]
    - path: "src/db/queries/drives.ts"
      provides: "Drive CRUD operations"
      exports: ["createDrive", "updateDrive", "getDriveById"]
    - path: "src/db/queries/events.ts"
      provides: "Event logging functions"
      exports: ["logEvent"]
    - path: "src/db/queries/breadcrumbs.ts"
      provides: "GPS breadcrumb storage"
      exports: ["logBreadcrumb"]
  key_links:
    - from: "src/services/DriveRecorder.ts"
      to: "src/db/queries/drives.ts"
      via: "createDrive on drive start"
      pattern: "createDrive\\("
    - from: "src/hooks/useDriveDetection.ts"
      to: "src/services/DriveRecorder.ts"
      via: "DriveRecorder.startDrive on state transition"
      pattern: "DriveRecorder\\.(startDrive|endDrive)"
    - from: "src/hooks/useAudioFeedback.ts"
      to: "src/services/DriveRecorder.ts"
      via: "DriveRecorder.logSpill on spill event"
      pattern: "DriveRecorder\\.logSpill"
---

<objective>
Implement drive session lifecycle management that captures drives, events, and GPS breadcrumbs to the database.

Purpose: Connect the existing drive detection system (Phase 2) to database persistence. When drives start/end, records are created. During drives, events (spills) and breadcrumbs are logged continuously.

Output: DriveRecorder service, database query functions, and integration with existing hooks.
</objective>

<execution_context>
@/Users/papanash/.claude/get-shit-done/workflows/execute-plan.md
@/Users/papanash/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-drive-session-management/03-CONTEXT.md
@.planning/phases/03-drive-session-management/03-RESEARCH.md
@.planning/phases/03-drive-session-management/03-01-SUMMARY.md
@src/hooks/useDriveDetection.ts
@src/hooks/useAudioFeedback.ts
@src/stores/useDriveStore.ts
@src/drive/types.ts
@src/db/schema/index.ts
@src/db/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database query functions</name>
  <files>src/db/queries/drives.ts, src/db/queries/events.ts, src/db/queries/breadcrumbs.ts, src/db/queries/index.ts</files>
  <action>
Create src/db/queries/drives.ts:
```typescript
import { eq, desc } from 'drizzle-orm';
import { db, generateId } from '../client';
import { drives } from '../schema';
import type { DifficultyLevel } from '../../stores/useSensorStore';

export interface CreateDriveParams {
  startTime: number;
  difficulty: DifficultyLevel;
  manualStart: boolean;
}

export interface UpdateDriveParams {
  endTime?: number;
  durationMs?: number;
  distanceMeters?: number;
  score?: number;
  spillCount?: number;
  potholeCount?: number;
  manualEnd?: boolean;
}

/**
 * Create a new drive record when drive starts
 */
export async function createDrive(params: CreateDriveParams): Promise<string> {
  const id = generateId();
  await db.insert(drives).values({
    id,
    startTime: params.startTime,
    difficulty: params.difficulty,
    manualStart: params.manualStart,
  });
  return id;
}

/**
 * Update drive record (typically at drive end)
 */
export async function updateDrive(driveId: string, params: UpdateDriveParams): Promise<void> {
  await db.update(drives).set(params).where(eq(drives.id, driveId));
}

/**
 * Get a drive by ID with events and breadcrumbs
 */
export async function getDriveById(driveId: string) {
  return db.query.drives.findFirst({
    where: eq(drives.id, driveId),
    with: {
      events: true,
      breadcrumbs: true,
    },
  });
}

/**
 * Get all completed drives, most recent first
 */
export async function getCompletedDrives(limit = 50) {
  return db.query.drives.findMany({
    where: (drives, { isNotNull }) => isNotNull(drives.endTime),
    orderBy: desc(drives.startTime),
    limit,
  });
}

/**
 * Get drive list with summary stats (no events/breadcrumbs)
 */
export async function getDrivesList(limit = 50) {
  return db.select().from(drives)
    .where(({ isNotNull }) => isNotNull(drives.endTime))
    .orderBy(desc(drives.startTime))
    .limit(limit);
}
```

Create src/db/queries/events.ts:
```typescript
import { eq } from 'drizzle-orm';
import { db, generateId } from '../client';
import { events } from '../schema';

export type EventType = 'spill' | 'pothole' | 'drive_start' | 'drive_end' | 'gps_lost' | 'gps_resumed';

export interface LogEventParams {
  driveId: string;
  type: EventType;
  timestamp: number;
  latitude?: number | null;
  longitude?: number | null;
  severity?: number | null;
  forgiven?: boolean;
}

/**
 * Log an event during a drive
 */
export async function logEvent(params: LogEventParams): Promise<string> {
  const id = generateId();
  await db.insert(events).values({
    id,
    driveId: params.driveId,
    type: params.type,
    timestamp: params.timestamp,
    latitude: params.latitude ?? null,
    longitude: params.longitude ?? null,
    severity: params.severity ?? null,
    forgiven: params.forgiven ?? false,
  });
  return id;
}

/**
 * Get all events for a drive
 */
export async function getEventsForDrive(driveId: string) {
  return db.select().from(events).where(eq(events.driveId, driveId));
}

/**
 * Count events by type for a drive
 */
export async function countEventsByType(driveId: string, type: EventType): Promise<number> {
  const result = await db.select().from(events)
    .where(eq(events.driveId, driveId))
    .where(eq(events.type, type));
  return result.length;
}
```

Create src/db/queries/breadcrumbs.ts:
```typescript
import { eq } from 'drizzle-orm';
import { db, generateId } from '../client';
import { breadcrumbs } from '../schema';

export interface LogBreadcrumbParams {
  driveId: string;
  timestamp: number;
  latitude: number;
  longitude: number;
  speed?: number | null;
}

/**
 * Log a GPS breadcrumb (called every ~5 seconds during drive)
 */
export async function logBreadcrumb(params: LogBreadcrumbParams): Promise<void> {
  await db.insert(breadcrumbs).values({
    id: generateId(),
    driveId: params.driveId,
    timestamp: params.timestamp,
    latitude: params.latitude,
    longitude: params.longitude,
    speed: params.speed ?? null,
  });
}

/**
 * Get all breadcrumbs for a drive (for route display)
 */
export async function getBreadcrumbsForDrive(driveId: string) {
  return db.select().from(breadcrumbs).where(eq(breadcrumbs.driveId, driveId));
}

/**
 * Calculate total distance from breadcrumbs using Haversine formula
 */
export function calculateDistance(crumbs: { latitude: number; longitude: number }[]): number {
  if (crumbs.length < 2) return 0;

  let totalDistance = 0;
  for (let i = 1; i < crumbs.length; i++) {
    totalDistance += haversineDistance(
      crumbs[i - 1].latitude, crumbs[i - 1].longitude,
      crumbs[i].latitude, crumbs[i].longitude
    );
  }
  return totalDistance;
}

/**
 * Haversine distance between two points in meters
 */
function haversineDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371000; // Earth radius in meters
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = Math.sin(dLat / 2) ** 2 +
            Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function toRad(deg: number): number {
  return deg * (Math.PI / 180);
}
```

Create src/db/queries/index.ts:
```typescript
export * from './drives';
export * from './events';
export * from './breadcrumbs';
```
  </action>
  <verify>Run `npx tsc --noEmit` - no TypeScript errors in query files</verify>
  <done>Database query functions created for drives, events, and breadcrumbs with typed parameters.</done>
</task>

<task type="auto">
  <name>Task 2: Create DriveRecorder service</name>
  <files>src/services/DriveRecorder.ts</files>
  <action>
Create src/services/DriveRecorder.ts:
```typescript
/**
 * DriveRecorder Service
 *
 * Orchestrates drive session lifecycle and event capture.
 * Singleton pattern - one active drive at a time.
 *
 * Usage:
 * - Call startDrive() when drive detection transitions to 'driving'
 * - Call logSpill() from audio feedback when spill triggers
 * - Call logBreadcrumb() every 5 seconds during drive
 * - Call endDrive() when drive detection transitions to 'idle'
 */

import { createDrive, updateDrive, getDriveById } from '../db/queries/drives';
import { logEvent, countEventsByType, EventType } from '../db/queries/events';
import { logBreadcrumb, getBreadcrumbsForDrive, calculateDistance } from '../db/queries/breadcrumbs';
import type { DifficultyLevel } from '../stores/useSensorStore';
import type { LocationData } from '../drive/types';

/** Breadcrumb interval in milliseconds (5 seconds per requirements) */
const BREADCRUMB_INTERVAL_MS = 5000;

class DriveRecorderClass {
  private currentDriveId: string | null = null;
  private driveStartTime: number | null = null;
  private lastBreadcrumbTime: number = 0;
  private spillCount: number = 0;
  private potholeCount: number = 0;

  /**
   * Check if a drive is currently being recorded
   */
  isRecording(): boolean {
    return this.currentDriveId !== null;
  }

  /**
   * Get current drive ID (for debugging)
   */
  getCurrentDriveId(): string | null {
    return this.currentDriveId;
  }

  /**
   * Start recording a new drive
   * Called when drive state transitions to 'driving' or 'manual_driving'
   */
  async startDrive(params: {
    startTime: number;
    difficulty: DifficultyLevel;
    manual: boolean;
    location?: LocationData | null;
  }): Promise<string> {
    // End any existing drive first (safety)
    if (this.currentDriveId) {
      console.warn('[DriveRecorder] Starting new drive while one is active, ending previous');
      await this.endDrive({ endTime: params.startTime, manual: false });
    }

    const driveId = await createDrive({
      startTime: params.startTime,
      difficulty: params.difficulty,
      manualStart: params.manual,
    });

    this.currentDriveId = driveId;
    this.driveStartTime = params.startTime;
    this.lastBreadcrumbTime = 0;
    this.spillCount = 0;
    this.potholeCount = 0;

    // Log drive_start event
    await logEvent({
      driveId,
      type: 'drive_start',
      timestamp: params.startTime,
      latitude: params.location?.latitude,
      longitude: params.location?.longitude,
    });

    // Log initial breadcrumb if location available
    if (params.location) {
      await this.recordBreadcrumb(params.location);
    }

    console.log(`[DriveRecorder] Drive started: ${driveId}`);
    return driveId;
  }

  /**
   * End the current drive
   * Called when drive state transitions to 'idle' from 'stopping'
   */
  async endDrive(params: {
    endTime: number;
    manual: boolean;
    location?: LocationData | null;
  }): Promise<void> {
    if (!this.currentDriveId || !this.driveStartTime) {
      console.warn('[DriveRecorder] No active drive to end');
      return;
    }

    const driveId = this.currentDriveId;
    const durationMs = params.endTime - this.driveStartTime;

    // Log drive_end event
    await logEvent({
      driveId,
      type: 'drive_end',
      timestamp: params.endTime,
      latitude: params.location?.latitude,
      longitude: params.location?.longitude,
    });

    // Calculate distance from breadcrumbs
    const breadcrumbs = await getBreadcrumbsForDrive(driveId);
    const distanceMeters = calculateDistance(breadcrumbs);

    // Update drive record with final stats
    // Note: Score is NOT calculated here - that's Plan 03's job
    await updateDrive(driveId, {
      endTime: params.endTime,
      durationMs,
      distanceMeters,
      spillCount: this.spillCount,
      potholeCount: this.potholeCount,
      manualEnd: params.manual,
    });

    console.log(`[DriveRecorder] Drive ended: ${driveId}, duration: ${durationMs}ms, distance: ${distanceMeters.toFixed(0)}m, spills: ${this.spillCount}`);

    // Reset state
    this.currentDriveId = null;
    this.driveStartTime = null;
    this.lastBreadcrumbTime = 0;
    this.spillCount = 0;
    this.potholeCount = 0;
  }

  /**
   * Log a spill event
   * Called from useAudioFeedback when spill sound triggers
   */
  async logSpill(params: {
    timestamp: number;
    location?: LocationData | null;
    severity: number; // risk value at time of spill (0-1)
  }): Promise<void> {
    if (!this.currentDriveId) {
      // Silently ignore spills outside of active drives
      return;
    }

    this.spillCount++;
    await logEvent({
      driveId: this.currentDriveId,
      type: 'spill',
      timestamp: params.timestamp,
      latitude: params.location?.latitude,
      longitude: params.location?.longitude,
      severity: params.severity,
    });

    console.log(`[DriveRecorder] Spill logged (${this.spillCount} total), severity: ${params.severity.toFixed(2)}`);
  }

  /**
   * Log a pothole event
   * Called from pothole detection (Phase 5, but we add the hook now)
   */
  async logPothole(params: {
    timestamp: number;
    location?: LocationData | null;
    severity: number;
    forgiven: boolean;
  }): Promise<void> {
    if (!this.currentDriveId) return;

    if (!params.forgiven) {
      this.potholeCount++;
    }

    await logEvent({
      driveId: this.currentDriveId,
      type: 'pothole',
      timestamp: params.timestamp,
      latitude: params.location?.latitude,
      longitude: params.location?.longitude,
      severity: params.severity,
      forgiven: params.forgiven,
    });

    console.log(`[DriveRecorder] Pothole logged, forgiven: ${params.forgiven}`);
  }

  /**
   * Record GPS breadcrumb
   * Should be called with every location update; internally throttles to 5s intervals
   */
  async recordBreadcrumb(location: LocationData): Promise<void> {
    if (!this.currentDriveId) return;

    // Throttle to BREADCRUMB_INTERVAL_MS
    const now = location.timestamp;
    if (now - this.lastBreadcrumbTime < BREADCRUMB_INTERVAL_MS) {
      return;
    }

    this.lastBreadcrumbTime = now;
    await logBreadcrumb({
      driveId: this.currentDriveId,
      timestamp: now,
      latitude: location.latitude,
      longitude: location.longitude,
      speed: location.speed,
    });
  }

  /**
   * Log GPS lost event
   */
  async logGpsLost(timestamp: number): Promise<void> {
    if (!this.currentDriveId) return;

    await logEvent({
      driveId: this.currentDriveId,
      type: 'gps_lost',
      timestamp,
    });
  }

  /**
   * Log GPS resumed event
   */
  async logGpsResumed(timestamp: number, location: LocationData): Promise<void> {
    if (!this.currentDriveId) return;

    await logEvent({
      driveId: this.currentDriveId,
      type: 'gps_resumed',
      timestamp,
      latitude: location.latitude,
      longitude: location.longitude,
    });
  }

  /**
   * Get stats for current drive (for UI display during drive)
   */
  getCurrentStats(): { spillCount: number; potholeCount: number; durationMs: number } | null {
    if (!this.currentDriveId || !this.driveStartTime) return null;

    return {
      spillCount: this.spillCount,
      potholeCount: this.potholeCount,
      durationMs: Date.now() - this.driveStartTime,
    };
  }
}

// Singleton instance
export const DriveRecorder = new DriveRecorderClass();
```
  </action>
  <verify>Run `npx tsc --noEmit src/services/DriveRecorder.ts` - no TypeScript errors</verify>
  <done>DriveRecorder service created with startDrive, endDrive, logSpill, logPothole, recordBreadcrumb methods.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate DriveRecorder with existing hooks</name>
  <files>src/hooks/useDriveDetection.ts, src/hooks/useAudioFeedback.ts, src/stores/useDriveStore.ts</files>
  <action>
Update src/hooks/useDriveDetection.ts to call DriveRecorder on state transitions:

Add import at top:
```typescript
import { DriveRecorder } from '../services/DriveRecorder';
import { useSensorStore } from '../stores/useSensorStore';
```

In the location callback processing, after state transitions:

When transitioning TO 'driving' or 'manual_driving' (detecting -> driving, or manual start):
```typescript
// After: setDriveState(newState);
if ((newState.type === 'driving' || newState.type === 'manual_driving') &&
    prevState.type !== 'driving' && prevState.type !== 'manual_driving') {
  const difficulty = useSensorStore.getState().difficulty;
  DriveRecorder.startDrive({
    startTime: newState.startTime,
    difficulty,
    manual: newState.type === 'manual_driving',
    location: locationData,
  }).catch(err => console.error('[DriveDetection] Failed to start drive recording:', err));
}
```

When transitioning FROM driving states TO idle (stopping -> idle):
```typescript
if (newState.type === 'idle' &&
    (prevState.type === 'stopping' || prevState.type === 'driving' || prevState.type === 'manual_driving')) {
  DriveRecorder.endDrive({
    endTime: Date.now(),
    manual: prevState.type === 'manual_driving',
    location: locationData,
  }).catch(err => console.error('[DriveDetection] Failed to end drive recording:', err));
}
```

During active drive, record breadcrumbs:
```typescript
// In location processing, when drive is active
if (isDriving(currentState)) {
  DriveRecorder.recordBreadcrumb(locationData)
    .catch(err => console.error('[DriveDetection] Failed to record breadcrumb:', err));
}
```

Update src/hooks/useAudioFeedback.ts to call DriveRecorder on spill:

Add import:
```typescript
import { DriveRecorder } from '../services/DriveRecorder';
import { useDriveStore } from '../stores/useDriveStore';
```

When spill sound is triggered (where 'spill' sound is played):
```typescript
// After triggering spill sound
if (sound === 'spill') {
  const lastLocation = useDriveStore.getState().lastLocation;
  DriveRecorder.logSpill({
    timestamp: Date.now(),
    location: lastLocation,
    severity: risk, // the risk value that triggered the spill
  }).catch(err => console.error('[AudioFeedback] Failed to log spill:', err));
}
```

Note: Keep all DriveRecorder calls non-blocking with .catch() to avoid blocking sensor/audio pipeline.
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Start app, go for a test drive:
   - Check console logs for "[DriveRecorder] Drive started"
   - Check console logs for breadcrumb recording
   - Trigger a spill, check "[DriveRecorder] Spill logged"
   - Stop driving, check "[DriveRecorder] Drive ended"
  </verify>
  <done>DriveRecorder integrated: drives created on start, breadcrumbs logged every 5s, spills logged on trigger, drives finalized on end with duration/distance/counts.</done>
</task>

</tasks>

<verification>
1. Start app, begin driving (auto or manual)
2. Check console: "[DriveRecorder] Drive started: {uuid}"
3. Drive for 15+ seconds, check breadcrumb logs
4. Trigger a spill (hard braking), check spill logged with severity
5. Stop driving, check: "[DriveRecorder] Drive ended" with duration and distance
6. Kill and restart app
7. Query database (via debug UI or direct inspection) - drive should persist with events
</verification>

<success_criteria>
- DriveRecorder.startDrive creates drive record with correct startTime and difficulty
- GPS breadcrumbs recorded every 5 seconds during active drive
- Spill events logged with timestamp, location, and severity
- Drive end updates record with duration, distance (from Haversine), spill count
- Data persists after app restart (survives app kill)
- All database operations non-blocking (use .catch() pattern)
</success_criteria>

<output>
After completion, create `.planning/phases/03-drive-session-management/03-02-SUMMARY.md`
</output>
