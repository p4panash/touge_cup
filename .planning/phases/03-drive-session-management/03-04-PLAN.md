---
phase: 03-drive-session-management
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - App.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Database migrations run before app renders main content"
    - "App shows loading state while migrations run"
    - "App shows error state if migrations fail"
  artifacts:
    - path: "App.tsx"
      provides: "Database initialization before app content"
      contains: "useDatabaseMigrations"
  key_links:
    - from: "App.tsx"
      to: "src/db/client.ts"
      via: "imports and calls useDatabaseMigrations"
      pattern: "import.*useDatabaseMigrations"
---

<objective>
Wire database initialization to app lifecycle by calling useDatabaseMigrations in App.tsx.

Purpose: Close critical gap from 03-VERIFICATION.md. The persistence code exists but migrations never run because useDatabaseMigrations is exported but not called. Without this, the first drive start crashes with "no such table: drives" error.

Output: App.tsx calls useDatabaseMigrations before rendering MainScreen, with proper loading/error states.
</objective>

<execution_context>
@/Users/papanash/.claude/get-shit-done/workflows/execute-plan.md
@/Users/papanash/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-drive-session-management/03-VERIFICATION.md
@src/db/client.ts
@App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add database initialization to App.tsx</name>
  <files>App.tsx</files>
  <action>
Update App.tsx to initialize database before rendering content:

1. Add import at top of file:
```typescript
import { useDatabaseMigrations } from '@/db/client';
```

2. Update the App component to check database status:

The current App component structure is:
- Checks audio init → shows LoadingScreen or error
- Once audio ready → renders MainScreen

The new structure should be:
- Check database migrations FIRST
- Then check audio init
- Once both ready → render MainScreen

Create a new component that wraps the existing logic:

```typescript
/**
 * Database initialization wrapper
 * Runs migrations before allowing app to render
 */
function DatabaseProvider({ children }: { children: React.ReactNode }) {
  const { success, error } = useDatabaseMigrations();

  if (error) {
    return (
      <View style={styles.container}>
        <Text style={styles.errorTitle}>Database Error</Text>
        <Text style={styles.errorText}>{error.message}</Text>
        <StatusBar style="light" />
      </View>
    );
  }

  if (!success) {
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color="#00d4ff" />
        <Text style={styles.loadingText}>Initializing database...</Text>
        <StatusBar style="light" />
      </View>
    );
  }

  return <>{children}</>;
}
```

3. Update the default App export to wrap content in DatabaseProvider:

```typescript
export default function App() {
  return (
    <DatabaseProvider>
      <AppContent />
    </DatabaseProvider>
  );
}
```

4. Rename the existing App function to AppContent (keeps all existing audio init logic).

The final structure:
- App() returns <DatabaseProvider><AppContent /></DatabaseProvider>
- DatabaseProvider handles migration loading/error
- AppContent handles audio loading/error and renders MainScreen

IMPORTANT: Database must initialize BEFORE audio engine, because future phases may need DB access during audio callbacks.
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Start app - should show "Initializing database..." briefly, then "Initializing audio...", then MainScreen
3. Check console for any SQLite errors - there should be none
4. Start a drive - should NOT crash with "no such table" error
  </verify>
  <done>Database initialization wired to app lifecycle. Migrations run before content renders. Loading and error states implemented.</done>
</task>

</tasks>

<verification>
1. App shows "Initializing database..." on fresh launch
2. App progresses to "Initializing audio..." after DB ready
3. MainScreen renders after both are ready
4. Starting a drive creates records without SQLite errors
5. Kill and restart app - drive data persists
</verification>

<success_criteria>
- useDatabaseMigrations imported and called in App.tsx
- Database initializes before audio engine
- Loading state shown while migrations run
- Error state shown if migrations fail
- No "no such table" errors when starting drives
- Data persists across app restarts
</success_criteria>

<output>
After completion, create `.planning/phases/03-drive-session-management/03-04-SUMMARY.md`
</output>
