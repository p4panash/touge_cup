---
phase: 03-drive-session-management
plan: 03
type: tdd
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/scoring/calculateScore.ts
  - src/scoring/calculateScore.test.ts
  - src/services/DriveRecorder.ts
  - src/hooks/useDriveHistory.ts
autonomous: true

must_haves:
  truths:
    - "Each completed drive has a smoothness score from 0-100"
    - "Score is calculated at drive end (reveal moment)"
    - "Score reflects spill count and severity"
    - "Completed drives appear in a list after app restart"
  artifacts:
    - path: "src/scoring/calculateScore.ts"
      provides: "Score calculation function"
      exports: ["calculateScore"]
    - path: "src/scoring/calculateScore.test.ts"
      provides: "Test cases for scoring logic"
      contains: "describe"
    - path: "src/hooks/useDriveHistory.ts"
      provides: "Hook for fetching drive list"
      exports: ["useDriveHistory"]
  key_links:
    - from: "src/services/DriveRecorder.ts"
      to: "src/scoring/calculateScore.ts"
      via: "calculates score at drive end"
      pattern: "calculateScore\\("
    - from: "src/hooks/useDriveHistory.ts"
      to: "src/db/queries/drives.ts"
      via: "fetches completed drives"
      pattern: "getCompletedDrives|getDrivesList"
---

<objective>
Implement score calculation engine using TDD and create hook for drive history display.

Purpose: Per CONTEXT.md, score is revealed at drive end as a "moment". This plan implements the scoring formula (100 - penalty per spill) and provides the useDriveHistory hook for Phase 4 UI.

Output: Tested scoring function, integrated with DriveRecorder, and useDriveHistory hook.
</objective>

<execution_context>
@/Users/papanash/.claude/get-shit-done/workflows/execute-plan.md
@/Users/papanash/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-drive-session-management/03-CONTEXT.md
@.planning/phases/03-drive-session-management/03-RESEARCH.md
@.planning/phases/03-drive-session-management/03-02-SUMMARY.md
@src/services/DriveRecorder.ts
@src/db/queries/drives.ts
@src/db/schema/drives.ts
</context>

<feature>
  <name>Score Calculation Engine</name>
  <files>src/scoring/calculateScore.ts, src/scoring/calculateScore.test.ts</files>
  <behavior>
Score calculation formula:
- Base score: 100
- Penalty per spill: varies by severity
  - Low severity (0.0-0.5): 5 points
  - Medium severity (0.5-0.7): 10 points
  - High severity (0.7-1.0): 15 points
- Minimum score: 0 (floor, never negative)
- Duration bonus: +1 point per 5 minutes of driving (up to +10 max)
- Perfect drive bonus: +5 if zero spills

Test cases:
- Perfect drive, 10 min: expect 100 + 2 (duration) + 5 (perfect) = 100 (capped)
- Perfect drive, 5 min: expect 100 + 1 + 5 = 100 (capped)
- 1 low-severity spill: expect 100 - 5 = 95
- 1 high-severity spill: expect 100 - 15 = 85
- 3 spills (low, med, high): expect 100 - 5 - 10 - 15 = 70
- 10 high-severity spills: expect 100 - 150 = 0 (floored)
- 20 spills: expect 0 (never negative)
  </behavior>
  <implementation>
1. RED: Write failing tests for all cases above
2. GREEN: Implement calculateScore function to pass tests
3. REFACTOR: Clean up if needed
4. Integrate: Call calculateScore from DriveRecorder.endDrive()
5. Create useDriveHistory hook for fetching completed drives
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for score calculation (RED)</name>
  <files>src/scoring/calculateScore.test.ts</files>
  <action>
First, install jest if not present:
```bash
npm install -D jest @types/jest ts-jest
```

Create jest.config.js if it doesn't exist:
```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/*.test.ts'],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
};
```

Create src/scoring/calculateScore.test.ts:
```typescript
import { calculateScore, ScoreInput, ScoreResult } from './calculateScore';

describe('calculateScore', () => {
  describe('perfect drives', () => {
    it('returns 100 for perfect 10-minute drive', () => {
      const input: ScoreInput = {
        spillEvents: [],
        durationMs: 10 * 60 * 1000, // 10 minutes
      };
      const result = calculateScore(input);
      expect(result.score).toBe(100);
      expect(result.isPerfect).toBe(true);
    });

    it('returns 100 for perfect 5-minute drive', () => {
      const input: ScoreInput = {
        spillEvents: [],
        durationMs: 5 * 60 * 1000,
      };
      const result = calculateScore(input);
      expect(result.score).toBe(100);
      expect(result.isPerfect).toBe(true);
    });

    it('returns 100 for perfect 1-minute drive (short drives ok)', () => {
      const input: ScoreInput = {
        spillEvents: [],
        durationMs: 1 * 60 * 1000,
      };
      const result = calculateScore(input);
      expect(result.score).toBe(100);
      expect(result.isPerfect).toBe(true);
    });
  });

  describe('spill penalties', () => {
    it('deducts 5 points for low severity spill (0.0-0.5)', () => {
      const input: ScoreInput = {
        spillEvents: [{ severity: 0.3 }],
        durationMs: 5 * 60 * 1000,
      };
      const result = calculateScore(input);
      expect(result.score).toBe(95);
      expect(result.breakdown.spillPenalty).toBe(5);
    });

    it('deducts 10 points for medium severity spill (0.5-0.7)', () => {
      const input: ScoreInput = {
        spillEvents: [{ severity: 0.6 }],
        durationMs: 5 * 60 * 1000,
      };
      const result = calculateScore(input);
      expect(result.score).toBe(90);
      expect(result.breakdown.spillPenalty).toBe(10);
    });

    it('deducts 15 points for high severity spill (0.7-1.0)', () => {
      const input: ScoreInput = {
        spillEvents: [{ severity: 0.9 }],
        durationMs: 5 * 60 * 1000,
      };
      const result = calculateScore(input);
      expect(result.score).toBe(85);
      expect(result.breakdown.spillPenalty).toBe(15);
    });

    it('accumulates penalties for multiple spills', () => {
      const input: ScoreInput = {
        spillEvents: [
          { severity: 0.3 },  // low: -5
          { severity: 0.6 },  // med: -10
          { severity: 0.9 },  // high: -15
        ],
        durationMs: 5 * 60 * 1000,
      };
      const result = calculateScore(input);
      expect(result.score).toBe(70);
      expect(result.breakdown.spillPenalty).toBe(30);
    });
  });

  describe('score floor', () => {
    it('never returns negative score', () => {
      const input: ScoreInput = {
        spillEvents: Array(20).fill({ severity: 0.9 }), // 20 * 15 = 300 penalty
        durationMs: 5 * 60 * 1000,
      };
      const result = calculateScore(input);
      expect(result.score).toBe(0);
    });

    it('returns 0 for 10 high-severity spills', () => {
      const input: ScoreInput = {
        spillEvents: Array(10).fill({ severity: 0.9 }), // 10 * 15 = 150 penalty
        durationMs: 5 * 60 * 1000,
      };
      const result = calculateScore(input);
      expect(result.score).toBe(0);
    });
  });

  describe('duration bonus', () => {
    it('adds 1 point per 5 minutes of driving', () => {
      const input: ScoreInput = {
        spillEvents: [{ severity: 0.3 }], // -5
        durationMs: 15 * 60 * 1000, // 15 min = +3
      };
      const result = calculateScore(input);
      // 100 - 5 + 3 = 98
      expect(result.score).toBe(98);
      expect(result.breakdown.durationBonus).toBe(3);
    });

    it('caps duration bonus at 10 points', () => {
      const input: ScoreInput = {
        spillEvents: [{ severity: 0.3 }], // -5
        durationMs: 120 * 60 * 1000, // 120 min = +24, capped to +10
      };
      const result = calculateScore(input);
      // 100 - 5 + 10 = 105, capped to 100
      expect(result.score).toBe(100);
      expect(result.breakdown.durationBonus).toBe(10);
    });
  });

  describe('score breakdown', () => {
    it('provides detailed breakdown', () => {
      const input: ScoreInput = {
        spillEvents: [
          { severity: 0.3 },
          { severity: 0.9 },
        ],
        durationMs: 10 * 60 * 1000,
      };
      const result = calculateScore(input);
      expect(result.breakdown).toEqual({
        baseScore: 100,
        spillPenalty: 20, // 5 + 15
        durationBonus: 2,  // 10 min = 2
        perfectBonus: 0,   // has spills
      });
      expect(result.score).toBe(82); // 100 - 20 + 2
    });
  });

  describe('severity edge cases', () => {
    it('treats severity at boundary 0.5 as medium', () => {
      const input: ScoreInput = {
        spillEvents: [{ severity: 0.5 }],
        durationMs: 5 * 60 * 1000,
      };
      const result = calculateScore(input);
      expect(result.breakdown.spillPenalty).toBe(10);
    });

    it('treats severity at boundary 0.7 as high', () => {
      const input: ScoreInput = {
        spillEvents: [{ severity: 0.7 }],
        durationMs: 5 * 60 * 1000,
      };
      const result = calculateScore(input);
      expect(result.breakdown.spillPenalty).toBe(15);
    });

    it('handles null severity as low', () => {
      const input: ScoreInput = {
        spillEvents: [{ severity: null }],
        durationMs: 5 * 60 * 1000,
      };
      const result = calculateScore(input);
      expect(result.breakdown.spillPenalty).toBe(5);
    });
  });
});
```

Run tests to confirm they fail:
```bash
npx jest src/scoring/calculateScore.test.ts
```

Tests MUST fail (RED phase) because calculateScore.ts doesn't exist yet.
  </action>
  <verify>Run `npx jest src/scoring/calculateScore.test.ts` - tests fail with "Cannot find module './calculateScore'"</verify>
  <done>Failing tests written covering: perfect drives, spill penalties by severity, score floor, duration bonus, breakdown details.</done>
</task>

<task type="auto">
  <name>Task 2: Implement score calculation to pass tests (GREEN)</name>
  <files>src/scoring/calculateScore.ts</files>
  <action>
Create src/scoring/calculateScore.ts:
```typescript
/**
 * Score Calculation Engine
 *
 * Calculates smoothness score (0-100) for completed drives.
 * Score is revealed at drive end as a "moment" (per CONTEXT.md).
 *
 * Formula:
 * - Base: 100
 * - Spill penalty: varies by severity (5/10/15 points)
 * - Duration bonus: +1 per 5 minutes (max +10)
 * - Perfect bonus: +5 if zero spills
 * - Floor: 0 (never negative)
 * - Ceiling: 100 (never above)
 */

export interface SpillEvent {
  severity: number | null;
}

export interface ScoreInput {
  spillEvents: SpillEvent[];
  durationMs: number;
}

export interface ScoreBreakdown {
  baseScore: number;
  spillPenalty: number;
  durationBonus: number;
  perfectBonus: number;
}

export interface ScoreResult {
  score: number;
  isPerfect: boolean;
  breakdown: ScoreBreakdown;
}

/** Penalty points by severity bracket */
const SEVERITY_PENALTIES = {
  low: 5,    // severity < 0.5
  medium: 10, // 0.5 <= severity < 0.7
  high: 15,   // severity >= 0.7
} as const;

/** Duration bonus: 1 point per this many ms */
const DURATION_BONUS_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes

/** Maximum duration bonus */
const MAX_DURATION_BONUS = 10;

/** Perfect drive bonus (zero spills) */
const PERFECT_BONUS = 5;

/** Base score before penalties/bonuses */
const BASE_SCORE = 100;

/**
 * Get penalty for a single spill based on severity
 */
function getPenaltyForSeverity(severity: number | null): number {
  // Treat null/undefined as low severity
  const s = severity ?? 0;

  if (s >= 0.7) return SEVERITY_PENALTIES.high;
  if (s >= 0.5) return SEVERITY_PENALTIES.medium;
  return SEVERITY_PENALTIES.low;
}

/**
 * Calculate smoothness score for a completed drive
 *
 * @param input - Spill events and duration
 * @returns Score (0-100) with breakdown
 */
export function calculateScore(input: ScoreInput): ScoreResult {
  const { spillEvents, durationMs } = input;

  // Calculate spill penalty
  const spillPenalty = spillEvents.reduce(
    (total, event) => total + getPenaltyForSeverity(event.severity),
    0
  );

  // Calculate duration bonus (capped)
  const rawDurationBonus = Math.floor(durationMs / DURATION_BONUS_INTERVAL_MS);
  const durationBonus = Math.min(rawDurationBonus, MAX_DURATION_BONUS);

  // Perfect bonus if no spills
  const isPerfect = spillEvents.length === 0;
  const perfectBonus = isPerfect ? PERFECT_BONUS : 0;

  // Calculate final score
  const rawScore = BASE_SCORE - spillPenalty + durationBonus + perfectBonus;

  // Apply floor (0) and ceiling (100)
  const score = Math.max(0, Math.min(100, rawScore));

  return {
    score,
    isPerfect,
    breakdown: {
      baseScore: BASE_SCORE,
      spillPenalty,
      durationBonus,
      perfectBonus,
    },
  };
}
```

Run tests:
```bash
npx jest src/scoring/calculateScore.test.ts
```

All tests MUST pass (GREEN phase).
  </action>
  <verify>Run `npx jest src/scoring/calculateScore.test.ts` - all tests pass</verify>
  <done>Score calculation implemented: severity-based penalties, duration bonus (capped at 10), perfect drive bonus, score floored at 0 and capped at 100.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate scoring and create useDriveHistory hook</name>
  <files>src/services/DriveRecorder.ts, src/hooks/useDriveHistory.ts</files>
  <action>
Update src/services/DriveRecorder.ts to calculate score at drive end:

Add import:
```typescript
import { calculateScore } from '../scoring/calculateScore';
import { getEventsForDrive } from '../db/queries/events';
```

In endDrive() method, after getting breadcrumbs and before updateDrive():
```typescript
// Get spill events for scoring
const events = await getEventsForDrive(driveId);
const spillEvents = events
  .filter(e => e.type === 'spill')
  .map(e => ({ severity: e.severity }));

// Calculate score (the "reveal moment" per CONTEXT.md)
const scoreResult = calculateScore({
  spillEvents,
  durationMs,
});

// Update drive record with final stats INCLUDING score
await updateDrive(driveId, {
  endTime: params.endTime,
  durationMs,
  distanceMeters,
  score: scoreResult.score, // <-- Add this
  spillCount: this.spillCount,
  potholeCount: this.potholeCount,
  manualEnd: params.manual,
});

console.log(`[DriveRecorder] Drive ended: ${driveId}, score: ${scoreResult.score}${scoreResult.isPerfect ? ' (PERFECT!)' : ''}`);
```

Create src/hooks/useDriveHistory.ts:
```typescript
import { useState, useEffect, useCallback } from 'react';
import { getCompletedDrives, getDriveById } from '../db/queries/drives';

export interface DriveListItem {
  id: string;
  startTime: number;
  endTime: number | null;
  durationMs: number | null;
  distanceMeters: number | null;
  score: number | null;
  spillCount: number | null;
  potholeCount: number | null;
  difficulty: string;
}

/**
 * Hook for fetching completed drive history
 *
 * Usage:
 * ```tsx
 * const { drives, loading, error, refresh } = useDriveHistory();
 *
 * if (loading) return <Text>Loading...</Text>;
 * if (error) return <Text>Error: {error.message}</Text>;
 *
 * return (
 *   <FlatList
 *     data={drives}
 *     renderItem={({ item }) => <DriveItem drive={item} />}
 *     onRefresh={refresh}
 *     refreshing={loading}
 *   />
 * );
 * ```
 */
export function useDriveHistory(limit = 50) {
  const [drives, setDrives] = useState<DriveListItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchDrives = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const result = await getCompletedDrives(limit);
      setDrives(result as DriveListItem[]);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to fetch drives'));
    } finally {
      setLoading(false);
    }
  }, [limit]);

  useEffect(() => {
    fetchDrives();
  }, [fetchDrives]);

  return {
    drives,
    loading,
    error,
    refresh: fetchDrives,
  };
}

/**
 * Hook for fetching a single drive with full details
 */
export function useDriveDetail(driveId: string | null) {
  const [drive, setDrive] = useState<Awaited<ReturnType<typeof getDriveById>> | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    if (!driveId) {
      setDrive(null);
      return;
    }

    setLoading(true);
    setError(null);

    getDriveById(driveId)
      .then(result => setDrive(result ?? null))
      .catch(err => setError(err instanceof Error ? err : new Error('Failed to fetch drive')))
      .finally(() => setLoading(false));
  }, [driveId]);

  return { drive, loading, error };
}

/**
 * Group drives by day for display
 * Returns array of { date: string, drives: DriveListItem[] }
 */
export function groupDrivesByDay(drives: DriveListItem[]): { date: string; label: string; drives: DriveListItem[] }[] {
  const groups = new Map<string, DriveListItem[]>();

  for (const drive of drives) {
    const date = new Date(drive.startTime).toISOString().split('T')[0]; // YYYY-MM-DD
    const existing = groups.get(date) || [];
    existing.push(drive);
    groups.set(date, existing);
  }

  const today = new Date().toISOString().split('T')[0];
  const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];

  return Array.from(groups.entries()).map(([date, drives]) => ({
    date,
    label: date === today ? 'Today' : date === yesterday ? 'Yesterday' : formatDateLabel(date),
    drives,
  }));
}

function formatDateLabel(dateStr: string): string {
  const date = new Date(dateStr);
  return date.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' });
}
```
  </action>
  <verify>
1. Run `npx jest` - all tests pass
2. Run `npx tsc --noEmit` - no TypeScript errors
3. Complete a test drive, check console for score in "[DriveRecorder] Drive ended" log
4. Query database - drive record should have score populated
  </verify>
  <done>Score calculation integrated into DriveRecorder.endDrive(). useDriveHistory hook created for Phase 4 UI. groupDrivesByDay helper for Today/Yesterday/date headers.</done>
</task>

</tasks>

<verification>
TDD verification:
1. RED: Tests fail before implementation
2. GREEN: All tests pass after implementation
3. Commits: test commit, then feat commit

Integration verification:
1. Start and complete a test drive with at least one spill
2. Check console log shows score (e.g., "score: 85")
3. Kill and restart app
4. Verify score persists in database
5. Test useDriveHistory hook returns completed drives with scores
</verification>

<success_criteria>
- calculateScore returns 0-100 based on spills, duration, and perfection
- All test cases pass (severity brackets, floor, ceiling, bonuses)
- DriveRecorder.endDrive calculates and stores score
- Score appears in console log at drive end (the "reveal moment")
- useDriveHistory hook fetches completed drives with scores
- groupDrivesByDay provides Today/Yesterday/date labels for UI
</success_criteria>

<output>
After completion, create `.planning/phases/03-drive-session-management/03-03-SUMMARY.md`
</output>
